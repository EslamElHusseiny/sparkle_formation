#!/usr/bin/env ruby

require 'multi_json'
require 'nokogiri'
require 'fileutils'

STORE = '/tmp/aws-cfn-docs'
UPDATE_MAPPING = {
  'replacement' => :replacement,
  'no interruption' => :none,
  'interruption' => :interrupt,
  'not supported' => :unavailable
}


unless(File.directory?(STORE))
  FileUtils.mkdir_p(STORE)
  Dir.chdir(STORE) do
    unless(system('wget -q -r -l 1 -A "aws-*" "http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"'))
      puts "FAILED: Documentation fetching failed!"
      exit -1
    end
  end
end

aws_resources = {}

Dir.glob(File.join(STORE, '**/*.html')).each do |path|
  resource = nil
  begin
    file = Nokogiri::HTML(File.open(path, 'r'))
    type = file.css('h1.topictitle').text.strip
    if(type.include?(' '))
      next
    end
    resource = file.css('div.section').detect do |section|
      section.children.any? do |child|
        child.get_attribute(:class) == 'titlepage' &&
          child.text.include?('Properties')
      end
    end
    property_information = {}
    if(resource)
      resource = resource.css('div.variablelist').first
      names = resource.children.detect{|r| r.name == 'dl'}.children.find_all{|r| r.name == 'dt'}.map(&:text).map(&:strip)
      infos = resource.children.detect{|r| r.name == 'dl'}.children.find_all{|r| r.name == 'dd'}
      # names = resource.css('dt').css('span').map(&:text).map(&:strip)
      # infos = resource.css('dd')
      unless(names.size == infos.size)
        raise "Failed to align resource properties with information - #{type} (#{path})"
      end
      names.each_with_index do |name, idx|
        info = infos[idx]
        base_type = info.css('p').map(&:text).detect do |x|
          x.include?('Type')
        end || 'String'
        if(base_type.downcase.match(/(\s|^)list(\s|$)/))
          p_type = 'Array'
        elsif(base_type.include?('Type: String'))
          p_type = 'String'
        elsif(base_type.include?('Type: Boolean'))
          p_type = 'Boolean'
        elsif(base_type.include?('Type: Integer'))
          p_type = 'Number'
        elsif(base_type.include?('Type:') && base_type.include?('JSON') && base_type.include?('document'))
          p_type = 'JSON'
        else
          p_type = 'Unknown'
        end
        required = !!info.css('p').map(&:text).detect do |x|
          x.include?('Required:') && x.include?('Yes')
        end
        description = info.css('p').first.text.strip.split("\n").map(&:strip).join(' ')
        # update_info = info.css('p').map(&:text).detect do |x|
        #   x.include?('Update requires')
        # end.to_s.downcase
        full_text = info.text.downcase
        if(full_text.include?('updates are not supported') || full_text.include?('cannot update this property'))
          update_causes = :unavailable
        elsif(full_text.include?('update causes interrupt'))
          update_causes = :interrupt
        else
          links = info.css('a').map(&:text).map(&:downcase)
          update_causes = UPDATE_MAPPING.map do |match, value|
            value if links.any?{|a| a.include?(match)}
          end.compact.first || :unknown
        end

        property_information[name] = {
          :description => description,
          :required => required,
          :type => p_type,
          :update_causes => update_causes
        }
      end
      aws_resources[type] = {
        :properties => names,
        :full_properties => property_information
      }
    else
      resource = file.css('div.informaltable')
      if(resource)
        aws_resources[type] = {
          :properties => resource.css('tr').map{|tr|
            item = tr.css('td').first
            item ? item.text.strip : nil
          }.compact
        }
      else
        next
      end
    end
    aws_resources[type][:path] = File.basename(path)
  end
end

puts MultiJson.dump(aws_resources, :pretty => true)
